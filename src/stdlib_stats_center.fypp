#:include "common.fypp"
#:set RANKS = range(1, MAXRANK + 1)
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
submodule (stdlib_stats) stdlib_stats_center

  use, intrinsic:: ieee_arithmetic, only: ieee_value, ieee_quiet_nan
  use stdlib_error, only: error_stop
  use stdlib_optval, only: optval
  implicit none

contains

  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("center_all",rank, t1, k1)
      module function ${RName}$ (x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in), optional :: mask
        ${t1}$ :: res${shape('x', rank)}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._${k1}$, ieee_quiet_nan)
          return
        end if

        res = x - mean(x)

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('center_all', rank, t1, k1,'dp')
      module function ${RName}$(x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in), optional :: mask
        real(dp) :: res${shape('x', rank)}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._dp, ieee_quiet_nan)
          return
        end if

        res = real(x, dp) - mean(x)

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("center",rank, t1, k1)
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in), optional :: mask
        ${t1}$ :: res${shape('x', rank)}$

        integer :: i
        ${t1}$, allocatable :: mean_${ranksuffix(rank-1)}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._${k1}$, ieee_quiet_nan)
          return
        end if

        allocate(mean_, source = mean(x, dim))

        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            do i = 1, size(x, ${fi}$)
              res${select_subarray(rank, [(fi, 'i')])}$ = &
                x${select_subarray(rank, [(fi, 'i')])}$ - mean_
            end do
          #:endfor
        case default
          call error_stop("ERROR (center): wrong dimension")
        end select

        deallocate(mean_)

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("center",rank, t1, k1,'dp')
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in), optional :: mask
        real(dp) :: res${shape('x', rank)}$


        integer :: i
        real(dp), allocatable :: mean_${ranksuffix(rank-1)}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._dp, ieee_quiet_nan)
          return
        end if

        allocate(mean_, source = mean(x, dim))

        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            do i = 1, size(x, ${fi}$)
              res${select_subarray(rank, [(fi, 'i')])}$ = &
                real(x${select_subarray(rank, [(fi, 'i')])}$, dp) - mean_
            end do
          #:endfor
        case default
          call error_stop("ERROR (center): wrong dimension")
        end select

        deallocate(mean_)

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('center_mask_all',rank, t1, k1)
      module function ${RName}$(x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in) :: mask${ranksuffix(rank)}$
        ${t1}$ :: res${shape('x', rank)}$

        res = 0
        where(mask) res = x - mean(x, mask)

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('center_mask_all',rank, t1, k1, 'dp')
      module function ${RName}$(x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in) :: mask${ranksuffix(rank)}$
        real(dp) :: res${shape('x', rank)}$

        res = 0
        where(mask) res = real(x, dp) - mean(x, mask)

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('center_mask',rank, t1, k1)
      module function  ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in) :: mask${ranksuffix(rank)}$
        ${t1}$ :: res${shape('x', rank)}$

        integer :: i
        ${t1}$, allocatable :: mean_${ranksuffix(rank-1)}$

        allocate(mean_, source = mean(x, dim, mask))

        res = 0

        select case(dim)
          #:if rank == 1
            case(1)
              where(mask)&
                res = x - mean_
          #:else
            #:for fi in range(1, rank+1)
            case(${fi}$)
              do i = 1, size(x, ${fi}$)
                where(mask${select_subarray(rank, [(fi, 'i')])}$)&
                  res${select_subarray(rank, [(fi, 'i')])}$ = &
                    x${select_subarray(rank, [(fi, 'i')])}$ - mean_
              end do
            #:endfor
          #:endif
        case default
          call error_stop("ERROR (center): wrong dimension")
        end select

        deallocate(mean_)

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('center_mask',rank, t1, k1, 'dp')
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in) :: mask${ranksuffix(rank)}$
        real(dp) :: res${shape('x', rank)}$

        integer :: i
        real(dp), allocatable :: mean_${ranksuffix(rank-1)}$

        allocate(mean_, source = mean(x, dim, mask))

        res = 0

        select case(dim)
          #:if rank == 1
            case(1)
              where(mask)&
                res = real(x, dp) - mean_
          #:else
            #:for fi in range(1, rank+1)
            case(${fi}$)
              do i = 1, size(x, ${fi}$)
                where(mask${select_subarray(rank, [(fi, 'i')])}$)&
                  res${select_subarray(rank, [(fi, 'i')])}$ = &
                    real(x${select_subarray(rank, [(fi, 'i')])}$, dp) - mean_
              end do
            #:endfor
          #:endif
        case default
          call error_stop("ERROR (center): wrong dimension")
        end select

        deallocate(mean_)

      end function ${RName}$
    #:endfor
  #:endfor

end submodule
